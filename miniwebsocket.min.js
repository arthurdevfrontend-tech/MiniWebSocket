const EventEmitter = require("events")

class MiniWebSocket {
  constructor(url, options = {}) {
    super();
    (this.url = url),
      (this.options = {
        reconnectInterval: options.reconnectInterval || 2e3,
        maxReconnectAttempts: options.maxReconnectAttempts || 1 / 0,
        debug: options.debug || false,
        historyLimit: options.historyLimit || 100,
      }),
      (this.reconnectAttempts = 0),
      (this.rooms = new Set()),
      this.connect();
      this.chatHistory = new Map();
      this.messageQuece = [];

  }

  log(...args) {
    if (this.options.debug) console.log(...args);
  }

  flsuhQueue() {
    while (this.messageQuece.length > 0 && this.socket.readyState == WebSocket.OPEN) {
      this.socket.send(this.messageQuece.shift());
    }
  }
  connect() {
    (this.socket = new WebSocket(this.url)),
      (this.socket.onopen = () => {
        (this.reconnectAttempts = 0),
          this.onOpen && this.onOpen(),
          console.log("üîó Conectado ao servidor WebSocket!");
      }),
      (this.socket.onmessage = (msg) => {
        try {
          const data = JSON.parse(msg.data);
          "room-message" === data.type && this.onRoomMessage
            ? this.onRoomMessage(data.room, data.message)
            : this.onMessage && this.onMessage(data);
        } catch {
          this.onMessage && this.onMessage(msg.data);
        }
      }),
      (this.socket.onerror = (err) => {
        this.onError && this.onError(err);
      }),
      (this.socket.onclose = () => {
        this.onClose && this.onClose(),
          console.log("‚ö†Ô∏è Conex√£o perdida..."),
          this.tryReconnect();
      });
  }
  tryReconnect() {
    this.reconnectAttempts < this.options.maxReconnectAttempts &&
      setTimeout(() => {
        this.reconnectAttempts++,
          console.log(`üîÑ Tentando reconectar... (${this.reconnectAttempts})`),
          this.connect();
      }, this.options.reconnectInterval);
  }
  send(message) {
    this.socket.readyState === WebSocket.OPEN
      ? this.socket.send(
          "string" == typeof message ? message : JSON.stringify(message)
        )
      : console.log("‚ùå N√£o foi poss√≠vel enviar, conex√£o fechada!");
  }
  broadcast(message) {
    this.send({ type: "broadcast", data: message });
  }
  joinRoom(room) {
    this.rooms.add(room), this.send({ type: "join-room", room: room });
  }
  leaveRoom(room) {
    this.rooms.delete(room), this.send({ type: "leave-room", room: room });
  }
  sendToRoom(room, message) {
    this.rooms.has(room)
      ? this.send({ type: "room-message", room: room, message: message })
      : console.log(`‚ö†Ô∏è Voc√™ n√£o est√° na sala: ${room}`);
  }
  ping() {
    this.send({ type: "ping" });
  }
  pong() {
    this.send({ type: "pong" });
  }
  getRoomSize(room) {
    // Conta quantos usu√°rios est√£o em uma sala
    return [...this.rooms].filter(r => r === room).length;
  }
  startPing(interval = 10000){
    setInterval(() => {
        this.ping(); 
    }, interval);
  }
  addMessageToHistory(room, message) {
    if (!this.chatHistory.has(room)) this.chatHistory.set(room, []);
    this.chatHistory.get(room).push(message);
  }
  sendDelayedMessage(room, message, delay) {
    setTimeout(() => this.sendToRoom(room, message) , delay);
  }
  listUsers(room) { return [...this.room.get(room).users]; }
}
module.exports = MiniWebSocket;
